\documentclass[autodetect-engine,dvi=dvipdfmx,ja=standard,
               a4j,11pt]{bxjsarticle}

%%======== プレアンブル ============================================%%
\RequirePackage{geometry}
\geometry{reset,a4paper}
\geometry{hmargin=25truemm,top=25truemm,bottom=25truemm,footskip=10truemm}
% \geometry{showframe} % はみ出し確認用

\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage{subfigure}

%%======== レポートタイトル等 ======================================%%
\title{プログラミング演習2 \\
       期末レポート}

\author{氏名: 池田 海斗 (IKEDA, Kaito) \\
        学生番号: 09501502}

\date{出題日: 2020年04月22日 \\
      提出日: 2020年07月28日 \\
      締切日: 2020年07月29日 \\}

%%======== 本文 ====================================================%%
\begin{document}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{概要} \label{sec:1}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本演習では，C言語を用いて名簿管理プログラムの制作を行う．
このプログラムではコマンド入力によるデータの読み込み$\cdot$書き出しを行ったり，整列$\cdot$検索を行うことができる．
また，標準入力からコンマで区切られた文字列を入力しデータの登録を行うことができる．

本レポートでは，演習中に取り組んだ課題として，
以下の課題1から課題10についての内容を報告する．

\begin{description}
  \item[課題1] 文字列操作の基礎：\verb|subst|関数と\verb|split|関数の実装
  \item[課題2] 構造体や配列を用いた名簿データの定義
  \item[課題3] 標準入力の取得と構文解析
  \item[課題4] CSVデータ登録処理の実装
  \item[課題5] コマンド中継処理の実装
  \item[課題6] コマンドの実装：\verb|%P|コマンド
  \item[課題7] コマンドの実装：\verb|%R|コマンドと\verb|%W|コマンド
  \item[課題8] コマンドの実装：\verb|%F|コマンド
  \item[課題9] コマンドの実装：\verb|%S|コマンド
  \item[課題10] 独自コマンドの実装

\end{description}

また，取り組んだ課題のうち，以下の課題については詳細な考察を行った．

\begin{description}
  \item[課題1] 文字列操作の基礎：\verb|subst|関数と\verb|split|関数の実装
  \item[課題3] 標準入力の取得と構文解析
  \item[課題6] コマンドの実装：\verb|%P|コマンド
  \item[課題7] コマンドの実装：\verb|%R|コマンドと\verb|%W|コマンド
  \item[課題9] コマンドの実装：\verb|%S|コマンド
  \item[課題10] 独自コマンドの実装
\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{プログラムの作成方針} \label{sec:2}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本演習で作成したプログラムが満たすべき要件と仕様として，
「(1) 基本要件」と「(2) 基本仕様」を示す．

\subsubsection*{(1) 基本要件}

\begin{enumerate}
  \setlength{\parskip}{0em} \setlength{\itemsep}{0.25em}
    \item プログラムは，その実行中，少なくとも10,000件の名簿データをメモリ中に保持できるようにすること．
    \item 名簿データは，「ID, 氏名, 誕生日, 住所, 備考」を，1つのデータとして扱えるようにすること．
    \item プログラムとしての動作や名簿データの管理のために，以下の機能を持つコマンドを実装すること．
    \begin{enumerate} \setlength{\parskip}{0em} \setlength{\itemsep}{0.25em}
        \item プログラムの正常な終了
        \item 登録された名簿データのデータ数表示
        \item 名簿データの全数表示，および，部分表示
        \item 名簿データのファイルへの保存，および，ファイルからの復元
        \item 名簿データの検索と表示
        \item 名簿データの整列
    \end{enumerate}
    \item 標準入力からのユーザ入力を通して，データ登録やデータ管理等の操作を可能とすること．
    \item 標準出力には，コマンドの実行結果のみを出力すること．
\end{enumerate}

\subsubsection*{(2) 基本仕様}

\begin{enumerate}
  \setlength{\parskip}{0em} \setlength{\itemsep}{0.25em}
    \item 名簿データは，コンマ区切りの文字列（\textbf{CSV入力}と呼ぶ）で表されるものとし，
          図\ref{fig:csvdata}に示したようなテキストデータを処理できるようにする．
    \item コマンドは，\%で始まる文字列（\textbf{コマンド入力}と呼ぶ）とし，
          表\ref{tab:commands}にあげたコマンドをすべて実装する．
    \item 1つの名簿データは，C言語の構造体 (\texttt{struct}) を用いて，
          構造を持ったデータとしてプログラム中に定義し，利用する．
    \item 全名簿データは，``何らかのデータ構造''を用いて，メモリ中に保持できるようにする．
    \item コマンドの実行結果以外の出力は，標準エラー出力に出力する．
\end{enumerate}

%========================= EXAMPLE CSV ================================%
\begin{figure}[b]
\centering
\begin{Verbatim}[frame=single, xleftmargin=10mm, xrightmargin=5mm, gobble=4,
                 fontsize=\small, numbers=left, firstnumber=1]
    5100046,The Bridge,1845-11-2,14 Seafield Road Longman Inverness,SEN Unit 2.0 Open
    5100127,Bower Primary School,1908-1-19,Bowermadden Bower Caithness,01955 641225 ...
    5100224,Canisbay Primary School,1928-7-5,Canisbay Wick,01955 611337 Primary 56 3...
    5100321,Castletown Primary School,1913-11-4,Castletown Thurso,01847 821256 01847...
\end{Verbatim}
    \caption{名簿データのCSV入力形式の例．1行におさまらないデータは...で省略した．}
    \label{fig:csvdata}
\end{figure}
%========================= EXAMPLE CSV ================================%

%========================= COMMAND LIST ================================%
\begin{table}[b]
\centering
    \caption{実装するコマンド}
    \label{tab:commands}
    \begin{tabular}{|l|ll|l|}
    \hline
    \textbf{コマンド} & \textbf{意味} & & \textbf{備考} \\
    \hline\hline
    \verb|%Q| & 終了 & (Quit) & \\
    \hline
    \verb|%C| & 登録内容のチェック & (Check) & 1行目に登録数を必ず表示 \\
    \hline
    \verb|%P n| & 先頭から$n$件表示 & (Print) & $n$が$0$ $\to$ 全件表示， \\
                & & & $n$が負 $\to$ 後ろから$-n$件表示 \\
    \hline
    \verb|%R file| & $file$から読込み & (Read) & \\
    \hline
    \verb|%W file| & $file$への書出し & (Write) & \\
    \hline
    \verb|%F word| & 検索結果を表示 & (Find) & \verb|%P|と同じ形式で表示 \\
    \hline
    \verb|%S n| & $CSV$の$n$番目の項目で整列 & (Sort) & 表示はしない \\
    \hline
    \end{tabular}
\end{table}
%========================= COMMAND LIST ================================%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{プログラムの説明} \label{sec:3}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

プログラムリストは\ref{sec:8}章に添付している．
プログラムは全部で743行からなる．
以下では，\ref{sec:1}節の課題ごとに，プログラムの主な構造について説明する．

%--------------------------------------------------------------------%
\subsection{文字列操作の基礎：\texttt{subst}関数と\texttt{split}関数の実装}
%--------------------------------------------------------------------%

まず，汎用的な文字列操作関数として，
\verb|subst()|関数を590--606行目で宣言し，
\verb|split()|関数を616--634行目で宣言している．
また，これらの関数で利用するために，\verb|stdio.h|，\verb|string.h|のヘッダファイルを読み込んでいる．

\verb|subst(STR, C1, C2)|関数は，
\verb|STR|が指す文字列中の，文字\verb|C1|を文字\verb|C2|に置き換える．
プログラム中では，\verb|get_line()|関数の中で，
文字``\verb|\n|''を終端ヌル文字``\verb|\0|''置き換えるために，この関数を呼び出している．
この関数では，文字\verb|C1|を文字\verb|C2|に置き換えた回数を返り値とする．

\verb|split(STR, RET, SEP, MAX)|関数では，
\verb|STR|が指す文字列を，最大\verb|MAX|個まで文字\verb|SEP|の箇所で区切り，配列\verb|RET|に格納していく．
プログラム中では，\verb|get_line()|関数で取得した1行を，カンマで区切りで配列に格納する際に呼び出される．
また，ハイフン区切りで入力される生年月日のデータを，年$\cdot$月$\cdot$日に分けて配列に格納する際にも用いる．
この関数では，配列に分割された個数を返り値とする．

%--------------------------------------------------------------------%
\subsection{構造体や配列を用いた名簿データの定義}
%--------------------------------------------------------------------%

本プログラムでは，構造体の配列に名簿データを格納していく．
20--25行目で，\verb|date|構造体を定義し，
35--42行目で，\verb|profile|構造体を定義している．
ID, 氏名, 誕生日, 住所, 備考の5つの組み合わせで1つの名簿データとなる．
名簿データの誕生日の箇所については\verb|date|構造体を用い，年$\cdot$月$\cdot$日を\verb|int|型として別々に保存しておく．
こうすることで，並び替えなどを行う際に効率よく実行ができる．

そして，51行目の\verb|profile_data_store|変数で全名簿データを管理し，
50行目の\verb|profile_data_nitems|変数で，名簿データの個数を管理している．

%--------------------------------------------------------------------%
\subsection{標準入力の取得と構文解析}
%--------------------------------------------------------------------%

\verb|get_line(LINE)|関数は，
ファイルポインタが設定されていて，かつ読み込む行がある場合にそのデータを1行ずつ取り出し，
そうでない場合には標準入力で読み込まれた名簿データを1行ずつ取り出し，\verb|LINE|に格納する．
読み込む行がない場合や，文字列が1024文字を超える場合に返り値\verb|0|を返す．

\verb|parse_line(LINE)|関数では，
\verb|get_line(LINE)|関数で読み込まれた1行が，コマンド入力かデータ入力であるか条件分岐を行う．
コマンドの場合，コマンド名と引数に分けてその値を\verb|exec_command(CMD, PARAM)|関数に引き渡し，
データ入力であった場合は\verb|new_profile(PROFILE_DATA_STORE, LINE)|関数で登録を行う．

%--------------------------------------------------------------------%
\subsection{CSVデータ登録処理の実装}
%--------------------------------------------------------------------%

\verb|new_profile(PROFILE_DATA_STORE, LINE)|関数内では，
グローバル変数\verb|profile_data_store|の任意の配列番号のポインタを受け取る．
\verb|split|関数を用いて1行をカンマで5つに区切り，その中の3番目の要素を更にハイフンで3つに区切る．
そして，それぞれの要素をID$\cdot$名前$\cdot$誕生日$\cdot$住所$\cdot$備考として，
配列\verb|profile_data_store|の\verb|profile_data_nitems|番目の要素としてデータを保存する．
誕生日に関しても同様，構造体\verb|date|の型で年$\cdot$月$\cdot$日に細分化しデータを格納する．
また，並び替えを行いやすいように，ID$\cdot$誕生日に関しては\verb|int|型に変換して保存する．

%--------------------------------------------------------------------%
\subsection{コマンド中継処理の実装}
%--------------------------------------------------------------------%

\verb|exec_command(CMD, PARAM)|関数では，
コマンド文字と引数を受け取りそれによって関数を呼び出す，
案内所のような役割を行っている．
引数は文字列に対応させるため，ポインタで取得するようにしてある．
また一致するコマンドが見つからない場合，処理は行わないようにしてある．

%--------------------------------------------------------------------%
\subsection{コマンドの実装：\texttt{\%P}コマンド}
%--------------------------------------------------------------------%

\verb|cmd_print(CMD, PARAM)|関数内では，
入力された引数が0，正，負であるかによって条件分岐される．
また，登録されている要素数の絶対値より大きい引数が入力された場合，
要素数分の処理のみ実行する．
また，出力のフォーマットは\verb|db_sample|と同じように揃えている．
引数が不正な値である場合でも，\verb|atoi()|関数を用いることで
$0$を入力したのと同様の動作を行うようにしてある．
これは\verb|db_sample|と同じ仕様である．

%--------------------------------------------------------------------%
\subsection{コマンドの実装：\texttt{\%R}コマンドと\texttt{\%W}コマンド}
%--------------------------------------------------------------------%

\verb|cmd_read|関数内では，
入力された引数名のファイルを開いてデータを読み込む処理を行う．
またファイル名が不正な値であった場合は，標準エラー出力に書き出すようにしている．
正常に読み込みが行えた場合には，\verb|get_line()|関数，\verb|parse_line()|関数を呼び出して
登録$\cdot$コマンド処理を行う．

\verb|cmd_write|関数内では，
入力された引数名のファイルにデータを保存する処理を行う．
またファイル名が不正な値であった場合は，標準エラー出力に書き出すようにしている．
正常に読み込みが行えた場合には，読み込むCSVファイルと同じ形式で
ID$\cdot$名前$\cdot$誕生日$\cdot$住所$\cdot$備考の組み合わせで1行ずつ書き出す．

%--------------------------------------------------------------------%
\subsection{コマンドの実装：\texttt{\%F}コマンド}
%--------------------------------------------------------------------%

\verb|cmd_find|関数では，
入力された引数と同じ要素を持つデータを出力する．
データは完璧に入力する必要があり，また日付は\verb|0000-00-00|の形式で入力する必要がある．

また一致するデータを2箇所持っていても出力は1回のみとなり，
一致するデータは全件表示される．

%--------------------------------------------------------------------%
\subsection{コマンドの実装：\texttt{\%S}コマンド}
%--------------------------------------------------------------------%

\verb|cmd_sort(CMD, PARAM)|関数では，
[名前-1]〜[備考-5]とし引数番目のカラムで並び替えを行う．

\verb|cmd_sort(CMD, PARAM)|関数では，新たに\verb|quicksort_name|関数，
\verb|quicksort_id|関数，\verb|quicksort_name|関数，
\verb|quicksort_birthday|関数，\verb|quicksort_address|関数，
\verb|quicksort_note|関数を用意し，それぞれ再起的に呼び出しクイックソートを行うようにした．

そして\verb|swap|関数では，\verb|profile_data_store[]|内の2データの入れ替えを行い，
\verb|compare_date|関数では返り値の正の数$\cdot$負の数$\cdot$ゼロで，日付の大小を比較できるようにした．

%--------------------------------------------------------------------%
\subsection{独自コマンドの実装}
%--------------------------------------------------------------------%

\verb|cmd_match(STRING, FIND)|関数内では，
入力された文字列に部分一致するデータを検索して出力する．
再起的に自身の関数を呼び出し，一致するものが見つかった場合返り値$1$を返す．
また\verb|upper(STRING)|関数も用意し，ポインタを渡すだけで文字列を大文字に変換できるようにした．
\verb|upper(STRING)|関数で利用するために，\verb|ctype.h|のヘッダファイルを読み込んでいる．
入力した文字列をこの関数にかけることで，大文字小文字関係なく探索を行えるようにしている．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{プログラムの使用法と実行結果} \label{sec:4}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%--------------------------------------------------------------------%
\subsection{プログラムの概要}
%--------------------------------------------------------------------%

本プログラムは名簿データを管理するためのプログラムである．
コマンドを入力する際には，\%で始まる英字を標準入力に打ち込み，引数で詳細な指示を行う．
コマンドの詳細は\ref{sec:2}節に記述してある．
また標準入力からのデータ入力も可能としている．

%--------------------------------------------------------------------%
\subsection{実行環境}
%--------------------------------------------------------------------%

プログラムは，MacOS Catalina 10.15.4 で動作を確認しているが，
一般的な UNIX で動作することを意図している．
なお，下記の実行例の行頭に書かれた「\verb|%|」は，
動作確認をしたMacOS Catalina 10.15.6におけるターミナルのプロンプトである．

%--------------------------------------------------------------------%
\subsection{コンパイル方法}
%--------------------------------------------------------------------%

まず，\verb|gcc|でコンパイルすることで，プログラムの実行ファイルを生成する．
ここで，\verb|-Wall|とは警告オプションを全て有効にするためのオプションであり，
\verb|-o|とは実行ファイルの名前を指定するオプションである．
これらのオプションをつけることで，コードの視認性を高めたり無駄なコードを省くことができ，
他のソースコードの実行ファイルとの識別が容易である．

{\fontsize{10pt}{11pt} \selectfont
 \begin{verbatim}
   % gcc -Wall -o eop_final_09501502 eop_final_09501502.c
 \end{verbatim}
}

%--------------------------------------------------------------------%
\subsection{実行方法}
%--------------------------------------------------------------------%

次に，プログラムを実行する．
以下の実行例は，プログラム実行中のデータの入力を模擬するため，
CSVファイルを標準入力により与えることで，実行する例を示している．
通常の利用においては，\verb|%R file|によりデータを読み込む．

{\fontsize{10pt}{11pt} \selectfont
 \begin{verbatim}
   % ./eop_final_09501502.out < stdin.csv
 \end{verbatim}
}

%--------------------------------------------------------------------%
\subsection{出力結果}
%--------------------------------------------------------------------%

第\ref{sec:8}章に記述してあるプログラムを実行すると，
プログラムの出力結果としてCSVデータの各項目が読みやすい形式で出力される．
例えば，下記の \verb|stdin.csv|，\verb|datastore.csv| に対して，

{\fontsize{10pt}{11pt} \selectfont
 \begin{verbatim}
  5100224,Canisbay Primary School,1928-7-5,Canisbay Wick,611337 Primary Open
  5100127,Bower Primary School,1908-1-19,Bowermadden Bower Caithness,641225 Primary Open
  %P -2
  %R datastore.csv
  5100046,The Bridge,1845-11-2,14 Seafield Road Longman Inverness,SEN Unit 2.0 Open
  %C
  %S 3
  %W stdout.csv
  %F The Bridge
  %M bridge
  %Q
 \end{verbatim}
}

{\fontsize{10pt}{11pt} \selectfont
 \begin{verbatim}
  5100925,Lybster Primary School,1863-7-7,Lybster Wick,721224 Primary Open
  5100720,Keiss Primary School,1863-7-3,Keiss Wick Caithness,631269 Primary Open
 \end{verbatim}
}

\noindent
以下のような出力が得られる．

{\fontsize{10pt}{11pt} \selectfont
 \begin{verbatim}
  Id    : 5100224
  Name  : Canisbay Primary School
  Birth : 1928-07-05
  Addr. : Canisbay Wick
  Comm. : 611337 Primary Open

  Id    : 5100127
  Name  : Bower Primary School
  Birth : 1908-01-19
  Addr. : Bowermadden Bower Caithness
  Comm. : 641225 Primary Open

  5 profile(s)

  Id    : 5100046
  Name  : The Bridge
  Birth : 1845-11-02
  Addr. : 14 Seafield Road Longman Inverness
  Comm. : SEN Unit 2.0 Open

  Id    : 5100046
  Name  : The Bridge
  Birth : 1845-11-02
  Addr. : 14 Seafield Road Longman Inverness
  Comm. : SEN Unit 2.0 Open
 \end{verbatim}
}

\noindent
以下は，生成された\verb|stdout.csv|ファイルの中身である．

{\fontsize{10pt}{11pt} \selectfont
 \begin{verbatim}
  5100046,The Bridge,1845-11-02,14 Seafield Road Longman Inverness,SEN Unit 2.0 Open
  5100720,Keiss Primary School,1863-07-03,Keiss Wick Caithness,631269 Primary Open
  5100925,Lybster Primary School,1863-07-07,Lybster Wick,721224 Primary Open
  5100127,Bower Primary School,1908-01-19,Bowermadden Bower Caithness,641225 Primary Open
  5100224,Canisbay Primary School,1928-07-05,Canisbay Wick,611337 Primary Open
 \end{verbatim}
}

まず，入力データについて説明する．
コマンドは\verb|%Q|, \verb|%C|, \verb|%P|, \verb|%R|, \verb|%W|, \verb|%F|,
 \verb|%S|, \verb|%M|の全てを記述している．
また，このCSVファイルから更に\verb|database.csv|ファイルのデータを読み込んでおり，
それぞれの項目はカンマで区切られている．
出力結果の整合性は，\verb|db-sample|の出力結果と，\verb|diff|コマンドを用いて確認してある．

処理内容は，データを2件登録，\verb|%P -2|コマンドで下から2件分表示，
\verb|%R datastore.csv|コマンドで\verb|datastore.csv|ファイルの読み込み，更に1件登録，
\verb|%C|コマンドで登録件数を表示，\verb|%S 3|コマンドで誕生日カラムで並び替え，
\verb|%W stdout.csv|コマンドで\verb|stdout.csv|に登録データの書き出し，
\verb|%F The Bridge|コマンドで\verb|The Bridge|をもつデータを表示，
\verb|%M bridge|コマンドで\verb|bridge|文字列を含むデータを表示，
\verb|%Q|コマンドで終了を行っている．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{考察} \label{sec:5}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ref{sec:3}章のプログラムの説明，および，\ref{sec:4}章の使用法と実行結果から，
演習課題として作成したプログラムが，
\ref{sec:1}章で述べた基本要件と基本仕様のいずれも満たしていることを示した．
ここでは，個別の課題のうち，以下の6つの項目について，考察を述べる．

\begin{enumerate}
\setlength{\parskip}{2pt} \setlength{\itemsep}{2pt}
    \item 文字列操作の基礎：\verb|subst|関数と\verb|split|関数の実装
    \item 標準入力の取得と構文解析
    \item コマンドの実装：\verb|%P|コマンド
    \item コマンドの実装：\verb|%R|コマンドと\verb|%W|コマンド
    \item コマンドの実装：\verb|%S|コマンド
    \item 独自コマンドの実装
\end{enumerate}

%--------------------------------------------------------------------%
\subsection{「文字列操作の基礎：\texttt{subst}関数と\texttt{split}関数の実装」に関する考察}
%--------------------------------------------------------------------%

\subsubsection{「\texttt{subst}関数」に関する考察}

ここでは\verb|subst|関数について考察を行う．
文字列の先頭にポインタを合わせて，その文字が置き換える対象の文字かどうか判断をして置換している．
ポインタをインクリメントして文字を進めてゆき，終端ヌル文字で終了する．
返り値は，置換した回数をカウントしておきその値とする．

\subsubsection{「\texttt{split}関数」に関する考察}

次に，\verb|split|関数についての考察を行う．
メモリを削減するために，1つの文字列にそれぞれの要素のポインタをつけていく仕様にしてある．
カンマを終端文字に置き換えることで，ポインタから終端文字までを1つの文字列とするため，
別変数に要素をコピーをする必要もない．
ポインタアドレスをコピーした後は，ポインタを終端ヌル文字の分1つ右へ移動させることで，
次の文字列の文頭にポインタを移動している．

%--------------------------------------------------------------------%
\subsection{「標準入力の取得と構文解析」に関する考察}
%--------------------------------------------------------------------%

\subsubsection{「\texttt{get\_line}関数」に関する考察}

\verb|get_line|関数についての考察を行う．
今回重要なポイントとなってくるところは，\verb|fgets|の最大文字数を1024ではなく1025に設定したところである．
もちろん，\verb|main|関数内で\verb|line|配列も1025文字にしているので，バッファオーバーフローを起こすことはない．
\verb|strlen|関数などのC言語の関数は終端ヌル文字をカウントしないことが多いので，
終端ヌル文字を別の文字に置き換えたりする場合でもエラーが起こらないように考慮した．

\subsubsection{「\texttt{parse\_line}関数」に関する考察}

次に，\verb|parse_line|関数についての考察を行う．
まずコマンドか否かの判別は，文字頭の値が\verb|%|で始まるかどうかで行っている．
これは，データ入力の場合文字列の始めは\verb|%|以外で始まるため，上記の条件に含まれることはないからである．
702行目では，ポインタの4文字目以降からヌル終端文字までを配列に格納している．

%--------------------------------------------------------------------%
\subsection{コマンドの実装：\texttt{\%P}コマンド}
%--------------------------------------------------------------------%

\verb|cmd_print(CMD, PARAM)|関数についての考察を行う．
まず，\verb|atoi()|関数で引数を\verb|int|型に変換する．
引数が0の場合，正の場合，負の場合で条件分岐を行う．
また，368行目$\cdot$ 383行目では，引数の絶対値が要素数よりも大きい場合は，要素数を用いて処理を行う．
今回考慮するべきは，引数が入力されていない場合や数字以外が入力された場合であり，
\verb|atoi()|関数ではそのような値に$0$という値を返すため
\verb|db_sample|の仕様通りになる．
*参考文献\cite{web:atoi}

%--------------------------------------------------------------------%
\subsection{コマンドの実装：\texttt{\%R}コマンドと\texttt{\%W}コマンド}
%--------------------------------------------------------------------%

\subsubsection{「\texttt{cmd\_read}関数」に関する考察}

\verb|cmd_read(CMD, PARAM)|関数についての考察を行う．
まず，ファイルポインタ\verb|fp|に読み込みファイルのポインタをあわせ，ファイルが存在していれば続行する．
これで\verb|fp|に情報が入っているので，\verb|get_line|関数で\verb|fp|から1行を読み取る処理に切り替わる．
\verb|get_line|関数と\verb|parse_line|関数をループするところは\verb|main|関数と同じ動作である．

\subsubsection{「\texttt{cmd\_write}関数」に関する考察}

次に，\verb|cmd_read(CMD, PARAM)|関数についての考察を行う．
ファイルポインタ\verb|fp|の取り扱いは\verb|cmd_read|関数と同じであり，ファイルが存在すれば上書き，または新規作成となる．
\verb|fprintf|関数とは，1つ目の引数（この場合\verb|fp|）に2つ目の引数の文字列を書き込むという関数である．

\verb|cmd_read|関数も\verb|cmd_write|関数も，ファイルが存在しない$\cdot$書き込み権限がない際の警告は
標準エラー出力に書き出すようにしている．

%--------------------------------------------------------------------%
\subsection{コマンドの実装：\texttt{\%S}コマンド}
%--------------------------------------------------------------------%

\verb|cmd_sort(CMD, PARAM)|関数についての考察を行う．
\verb|cmd_sort(CMD, PARAM)|関数では引数に応じて，\verb|switch|文で各クイックソート関数を呼び出している．
各クイックソート関数では自身を再起的に呼び出し，並び替えが完了すると処理が終了する．*参考文献\cite{book:algodata}

また，誕生日カラムのクイックソートについて，日付の大小を比べるために\verb|compare_date(D1, D2)|関数を用意した．
「年」の時点で大小が決まればその差を返し，もし同じだった場合には「月」を比べ，最終的には「日」の差を返す．
そのため関数の返り値で判別するには，正の数が返れば\verb|d1|の方が大きく，$0$が返れば日付が一致，
負の数が返れば\verb|d2|の方が大きいと処理する．

%--------------------------------------------------------------------%
\subsection{独自コマンドの実装}
%--------------------------------------------------------------------%

\verb|cmd_match(CMD, PARAM)|関数についての考察を行う．
まずこの関数の523行目$\cdot$ 524行目で，探索するデータを1行に戻しておき，探索回数をできるだけ少なくするように工夫した．

また，\verb|upper(STRING)|関数という，ポインタで渡された文字列を大文字に変換する関数を用意し，
部分一致検索に用いる変数を全て通してある．
これは検索時に大文字$\cdot$小文字関係なく入力できるようにするためである．

あとこの関数内では，\verb|match(STRING, FIND)|関数に渡し\verb|true|が返った場合，そのデータを出力するだけである．

\verb|match(STRING, FIND)|関数では，引数\verb|string| $\cdot$ \verb|find|を受け取る．
これはそれぞれ，探索対象となる文字列と探し出したい文字列のポインタである．
まず，306行目$\cdot$ 307行目でポインタのオリジナルを保存しておく．
仕様としては，\verb|string|のポインタを1文字ずつ進めてゆき，\verb|find|の先頭文字と一致すれば
\verb|string|と\verb|find|の両方のポインタを1文字ずらし，再び一致するかを繰り返していく．
一致しなかった場合は\verb|find|ポインタが先頭に戻され，
\verb|string|が終端ヌル文字まで到達かつ\verb|find|が終端ヌル文字まで到達していない場合，返り値$0$で終了する．
\verb|find|が終端ヌル文字まで到達した場合は返り値$1$で終了する．

ここで問題となるのが，\verb|string|がaabcd，\verb|find|がabcdの時である．
2文字目が一致しないので，\verb|find|ポインタが先頭に戻されてしまう．
そのため，非同期処理で（オリジナルの）\verb|find|文字列の1文字目が出てくるかの確認を随時行い，
検出された場合はその文字を先頭とする文字列とオリジナルの\verb|find|で再起呼び出しを行う．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{発展課題} \label{sec:6}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%--------------------------------------------------------------------%
\subsection{ポインタや構造体のサイズ}
%--------------------------------------------------------------------%

構造体\verb|profile|内の\verb|note|カラムに\verb|malloc|関数を用いることで，
構造体のサイズがどのくらい変わるのか，また，\verb|profile_data_store|をポインタにすることで
どのくらい構造体のサイズが変わるのか検証してみた．

まず，\verb|note|データを，\verb|malloc|関数を用いずにサイズ指定
（今回は1行が1024文字までなので\verb|note[1024]|）というに宣言してみた[\ref{sec:8.2}]．
\verb|sizeof|関数を用いて，\verb|struct profile|構造体のサイズと
\verb|profile_data_store|のサイズを確認する．

実行結果は以下の通りである．

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
    sizeof(struct profile) = 1184
    sizeof(profile_data_store) = 11840000
\end{Verbatim}

\verb|struct profile|自体のサイズは1184であることが分かった．
\verb|profile_data_store|は要素数10000の配列で宣言しているため，
サイズはその10000倍になっていることがわかる．

これを何気に使っていた\verb|malloc|関数でのデータ登録に変更すると，
以下のような結果になる．

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
    sizeof(struct profile) = 168
    sizeof(profile_data_store) = 1680000
\end{Verbatim}

値は1184から168と一気に小さくなった．
私はこの差，1016という値について考察してみた．
配列の要素数1024を取り除いたが，サイズが8だけ増加している．
そこで以下の出力を行ってみた．

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
    sizeof(char *) = 8
    sizeof(profile_data_store->note) = 8
    sizeof(struct profile) = 168
    sizeof(profile_data_store) = 1680000
\end{Verbatim}

これは，代わりに\verb|char|型のポインタを用意したために増加されたサイズであることが分かった．

次に，\verb|profile_data_store|をポインタにすることで，
どのくらい構造体のサイズが変わるのか検証してみた．

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
    sizeof(struct profile) = 168
    sizeof(profile_data_store) = 1680000
    sizeof(profile_data_store_ptr) = 80000
\end{Verbatim}

ポインタを使わない場合，1データ当たりのサイズ168を単純に10000個用意したサイズになっていたが，
ポインタを使う場合，1データ当たりのサイズが8となり確保するメモリのサイズが小さくなることがわかった．

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
    sizeof(struct profile *) = 8
\end{Verbatim}

%--------------------------------------------------------------------%
\subsection{パフォーマンスチューニング}
%--------------------------------------------------------------------%

次に，プログラムの実行速度を向上させるために，データの入れ替えをポインタを用いて行った．
時間計測にてパフォーマンスの改善を検証する．プログラムは\ref{sec:8.2}節に記載してある．
ここで注意しておきたいのが，C言語には\verb|clock()|と\verb|time()|の2種類が用意されてある．
\verb|clock()|はプロセス実行時間であり，同時実行している他のプロセスによって左右されてしまうため，
今回は\verb|time()|を用いて計測を行なっていきたいと思う．

処理自体はすぐに終了してしまうので，とりあえずソートを100回ずつ行う処理で比較していきたいと思う．
表\ref{tab:time100}は，処理をそれぞれ10回ずつ行ったときの平均値である．
明らかにポインタを使ったデータ交換の方が早いことがわかる．

小数では値が小さくなるほど数値の保証がされないので，1000回試行した結果も表\ref{tab:time1000}に記載しておく．

%========================= COMMAND LIST ================================%
\begin{table}[t]
    \begin{minipage}[t]{.45\textwidth}
        \centering
        \begin{tabular}{|l|l|l|}
            \hline
            \textbf{} & \textbf{通常} & \textbf{ポインタ} \\
            \hline\hline
            1 & 0.12444 & 0.10045 \\
            \hline
            2 & 0.11758 & 0.10185 \\
            \hline
            3 & 0.11889 & 0.10426 \\
            \hline
            4 & 0.12075 & 0.09961 \\
            \hline
            5 & 0.11305 & 0.09916 \\
            \hline
            6 & 0.12596 & 0.09763 \\
            \hline
            7 & 0.12282 & 0.10317 \\
            \hline
            8 & 0.11239 & 0.10752 \\
            \hline
            9 & 0.12051 & 0.10188 \\
            \hline
            10 & 0.11715 & 0.09994 \\
            \hline\hline
            平均 & 0.11935 & 0.10155 \\
            \hline
        \end{tabular}
    \caption{100回のソートにかかる時間}
        \label{tab:time100}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{.45\textwidth}
        \centering
        \begin{tabular}{|l|l|l|}
            \hline
            \textbf{} & \textbf{通常} & \textbf{ポインタ} \\
            \hline\hline
            1 & 0.72817 & 0.59453 \\
            \hline
            2 & 0.72894 & 0.59216 \\
            \hline
            3 & 0.72037 & 0.59088 \\
            \hline
            4 & 0.70810 & 0.60655 \\
            \hline
            5 & 0.72486 & 0.62740 \\
            \hline
            6 & 0.74986 & 0.61127 \\
            \hline
            7 & 0.73831 & 0.60605 \\
            \hline
            8 & 0.74023 & 0.59776 \\
            \hline
            9 & 0.70818 & 0.61044 \\
            \hline
            10 & 0.71994 & 0.60842 \\
            \hline\hline
            平均 & 0.72670 & 0.60455 \\
            \hline
        \end{tabular}
        \caption{1000回のソートにかかる時間}
        \label{tab:time1000}
    \end{minipage}
\end{table}
%========================= COMMAND LIST ================================%

%--------------------------------------------------------------------%
\subsection{不足機能の考察}
%--------------------------------------------------------------------%

不足機能として挙げられるのが，まずデータの削除を行うコマンドである．
不要になった登録データや誤入力のデータを削除する必要性は出てくる．

その実装方法について説明する．
今回はリストではなく配列でデータの登録を行っているため，
データを削除した後は配列を詰めていく必要がある．
削除するデータより後のデータを1つずつ\verb|for|文で1つ前にコピーしてゆき，
最後に\verb|profile_data_nitems|番目の値を初期化して，\verb|profile_data_nitems--|をすればよい．

また，データベースを活用するのも非常に大きな手だと思う．
\verb|MySQL|などのデータベースを扱うためのヘッダファイル\verb|mysql.h|なども用意されている *参考文献\cite{web:mysql}．
CSVファイルは何かと扱いにくく，カンマを含めないなどの汎用性も低い．
DBを活用することで入力値の正規化が必然となり，もちろん探索や挿入削除も高速に行えるため，
\verb|.csv|ではなく\verb|.db|として扱うメリットは大きいと考える．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{感想} \label{sec:7}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

今回のプログラムでは，\verb|split()|関数で苦労した．
私は最初，カンマ区切りの要素数よりも\verb|max|値の方が小さければ，
配列\verb|ret|の\verb|max|番目の要素には模範解答のように
残りの文字列をむりやり入れるような仕様にはしていなかった．
\ref{sec:8.4}節添付のコードのように，
受け取った文字列\verb|str|をまず初めに\verb|subst()|関数にかけることで，
カンマを全て終端\verb|NULL|文字に置き換え，ポインタを用いて一気に文字列を代入できる方法を実装した．
カンマを終端\verb|NULL|文字に置き換えるという発想自体は良かったのだが，
これだと仕様を満たしていなかったためテストを通過できなかった．
また，その模範解答との優劣を比較できるほどの能力がないことを悔しく感じた．

そしてデータ探索や整列など，普段何気なく使っている様々な言語のライブラリをいざアルゴリズムから考えて実装するとなると，
ものすごくわくわくする気持ちがある反面，完全な例外対策やアルゴリズムを突き詰めて処理を高速化するなど，
先人たちの努力の上にモジュールやパッケージなど使わせていただいてるんだなということが身に染みて感じた．

また，C言語にもともと用意されている関数を使う場面も多く，
リファレンスから行いたい処理をしてくれる関数を見つけ出す検索力も
プログラミングには必要だなと感じた．
希望する動作を行ってくれる関数を探し出す力，バグの原因と解決策を自分で見つけ出す力など，
行く行くはプログラムを行なっていく際に自分で解決する力を養うことが今の僕たちには大切だなと感じたた．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{作成したプログラム} \label{sec:8}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%--------------------------------------------------------------------%
\subsection{ソースコード} \label{sec:8.1}
%--------------------------------------------------------------------%

作成したプログラムを以下に添付する．
なお，\ref{sec:1}章に示した課題については，
\ref{sec:4}章で示したようにすべて正常に動作したことを付記しておく．

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <ctype.h>
#include <stdbool.h>

#define MAX_LINE_LEN 1024 /* Maximum characters per line */

bool show_size = false;    /* Whether to show size of struct */
bool swap_pointer = false; /* Whether to use pointer in swap function */
bool time_record = false;  /* Whether to record the time */

/*
Overview: Structure for specifying date.
@type: {int} y - Year.
@type: {int} m - Month.
@type: {int} d - Day.
*/
struct date
{
    int y;
    int m;
    int d;
};

/*
Overview: Structure for specifying user profiles.
@type: {int} id - ID.
@type: {char} name - Name.
@type: {struct date} birthday - Birthday.
@type: {char} address - Address.
@type: {char} note - Others.
*/
struct profile
{
    int id;
    char name[70];
    struct date birthday;
    char address[70];
    char *note;
};

/*
@type: {int} profile_data_nitems - Total number of registered items.
@type: {struct profile} profile_data_store[] - For storing registered data.
@type: {struct profile} profile_data_store_ptr[] - For storing pointer data.
@type: {FILE *} fp - Pointer for writing/reading.
*/
int profile_data_nitems = 0;
struct profile profile_data_store[10000];
struct profile *profile_data_store_ptr[10000];
FILE *fp;

int get_line(char *line);
void parse_line(char *line);

void make_profile_shadow(struct profile data_store[], struct profile *shadow[], int size)
{
    int i;
    for (i = 0; i < size; i++)
        shadow[i] = &data_store[i];
}

/*
Overview: Swap elements in profile_data_store array using pointer.
@argument: {struct profile*} source - Replacement source.
@argument: {struct profile*} destination - Replace destination.
@return: No return
*/
void swap_p(struct profile **source, struct profile **destination)
{
    struct profile *tmp;

    tmp = *source;
    *source = *destination;
    *destination = tmp;
}

/*
Overview: Swap elements in profile_data_store array.
@argument: {struct profile*} source - Replacement source.
@argument: {struct profile*} destination - Replace destination.
@return: No return
*/
void swap(struct profile *source, struct profile *destination)
{
    struct profile tmp;

    tmp = *source;
    *source = *destination;
    *destination = tmp;
}

/*
Overview: Quick sort profile_data_store array by id column.
@argument: {int} low - Left edge of quick sort.
@argument: {int} high - Right edge of quick sort.
@return: No return
*/
void quicksort_id(int low, int high)
{
    if (low < high)
    {
        int mid = (low + high) / 2;
        int x = profile_data_store_ptr[mid]->id;
        int i = low;
        int j = high;
        while (i <= j)
        {
            while (profile_data_store_ptr[i]->id < x)
                i += 1;
            while (profile_data_store_ptr[j]->id > x)
                j -= 1;
            if (i <= j)
                if (swap_pointer)
                    swap_p(&profile_data_store_ptr[i++], &profile_data_store_ptr[j--]);
                else
                    swap(profile_data_store_ptr[i++], profile_data_store_ptr[j--]);
            else
                ;
        }
        quicksort_id(low, j);
        quicksort_id(i, high);
    }
}

/*
Overview: Quick sort profile_data_store array by name column.
@argument: {int} low - Left edge of quick sort.
@argument: {int} high - Right edge of quick sort.
@return: No return
*/
void quicksort_name(int low, int high)
{
    if (low < high)
    {
        int mid, i, j;
        char x[70];
        mid = (low + high) / 2;
        strcpy(x, profile_data_store_ptr[mid]->name);
        i = low;
        j = high;
        while (i <= j)
        {
            while (strcmp(profile_data_store_ptr[i]->name, x) < 0)
                i += 1;
            while (strcmp(profile_data_store_ptr[j]->name, x) > 0)
                j -= 1;
            if (i <= j)
                if (swap_pointer)
                    swap_p(&profile_data_store_ptr[i++], &profile_data_store_ptr[j--]);
                else
                    swap(profile_data_store_ptr[i++], profile_data_store_ptr[j--]);
            else
                ;
        }
        quicksort_name(low, j);
        quicksort_name(i, high);
    }
}

/*
Overview: Compares two dates and returns the difference.
@argument: {struct date *} d1 - Date1.
@argument: {struct date *} d2 - Date2.
@return: {int} (Date1 - Date2) - Positive or negative or zero.
*/
int compare_date(struct date *d1, struct date *d2)
{
    if (d1->y != d2->y)
        return d1->y - d2->y;
    if (d1->m != d2->m)
        return d1->m - d2->m;
    return d1->d - d2->d;
}

/*
Overview: Quick sort profile_data_store array by birthday column.
@argument: {int} low - Left edge of quick sort.
@argument: {int} high - Right edge of quick sort.
@return: No return
*/
void quicksort_birthday(int low, int high)
{
    if (low < high)
    {
        int mid = (low + high) / 2;
        struct date x = profile_data_store_ptr[mid]->birthday;
        int i = low;
        int j = high;
        while (i <= j)
        {
            while (compare_date(&profile_data_store_ptr[i]->birthday, &x) < 0)
                i += 1;
            while (compare_date(&profile_data_store_ptr[j]->birthday, &x) > 0)
                j -= 1;
            if (i <= j)
                if (swap_pointer)
                    swap_p(&profile_data_store_ptr[i++], &profile_data_store_ptr[j--]);
                else
                    swap(profile_data_store_ptr[i++], profile_data_store_ptr[j--]);
            else
                ;
        }
        quicksort_birthday(low, j);
        quicksort_birthday(i, high);
    }
}

/*
Overview: Quick sort profile_data_store array by address column.
@argument: {int} low - Left edge of quick sort.
@argument: {int} high - Right edge of quick sort.
@return: No return
*/
void quicksort_address(int low, int high)
{
    if (low < high)
    {
        int mid, i, j;
        char x[70];
        mid = (low + high) / 2;
        strcpy(x, profile_data_store_ptr[mid]->address);
        i = low;
        j = high;
        while (i <= j)
        {
            while (strcmp(profile_data_store_ptr[i]->address, x) < 0)
                i += 1;
            while (strcmp(profile_data_store_ptr[j]->address, x) > 0)
                j -= 1;
            if (i <= j)
                if (swap_pointer)
                    swap_p(&profile_data_store_ptr[i++], &profile_data_store_ptr[j--]);
                else
                    swap(profile_data_store_ptr[i++], profile_data_store_ptr[j--]);
            else
                ;
        }
        quicksort_address(low, j);
        quicksort_address(i, high);
    }
}

/*
Overview: Quick sort profile_data_store array by note column.
@argument: {int} low - Left edge of quick sort.
@argument: {int} high - Right edge of quick sort.
@return: No return
*/
void quicksort_note(int low, int high)
{
    if (low < high)
    {
        int mid, i, j;
        char x[1024];
        mid = (low + high) / 2;
        strcpy(x, profile_data_store_ptr[mid]->note);
        i = low;
        j = high;
        while (i <= j)
        {
            while (strcmp(profile_data_store_ptr[i]->note, x) < 0)
                i += 1;
            while (strcmp(profile_data_store_ptr[j]->note, x) > 0)
                j -= 1;
            if (i <= j)
                if (swap_pointer)
                    swap_p(&profile_data_store_ptr[i++], &profile_data_store_ptr[j--]);
                else
                    swap(profile_data_store_ptr[i++], profile_data_store_ptr[j--]);
            else
                ;
        }
        quicksort_note(low, j);
        quicksort_note(i, high);
    }
}

/*
Overview: Converts lowercase letters to uppercase.
@argument: {char *} string - The string to convert.
@return: No return
*/
void upper(char *string)
{
    while (*string)
    {
        *string = toupper(*string);
        string++;
    }
}

/*
Overview: Search by partial match.
@argument: {char *} string - string to search.
@argument: {char *} find - string to find.
@return: No return
*/
int match(char *string, char *find)
{
    int i;
    char *string_tmp, *find_tmp;

    string_tmp = string;
    find_tmp = find;

    for (i = 0; i <= strlen(string); i++)
    {
        if (!*find_tmp)
            return 1;
        if (*string_tmp == *find && *string_tmp != *find_tmp)
            if (match(string_tmp, find))
                return 1;
        if (*string_tmp == *find_tmp)
            find_tmp++;
        else
            find_tmp = find;
        string_tmp++;
    }
    return 0;
}

/*
Overview: Exit the program.
@return: No return
*/
void cmd_quit(void)
{
    exit(0);
}

/*
Overview: Output the number of registrations.
@argument: {char} cmd - Command alphabet.
@return: No return
*/
void cmd_check(char cmd)
{
    printf("%d profile(s)\n", profile_data_nitems);
}

/*
Overview: Output data according to argument.
@argument: {char} cmd - Command alphabet.
@argument: {char *} param - Command argument.
@return: No return
*/
void cmd_print(char cmd, char *param)
{
    int count, num = atoi(param);
    if (num == 0)
    {
        count = 0;
        while (count < profile_data_nitems)
        {
            printf("Id    : %d\n", profile_data_store_ptr[count]->id);
            printf("Name  : %s\n", profile_data_store_ptr[count]->name);
            printf("Birth : %04d-%02d-%02d\n", profile_data_store_ptr[count]->birthday.y,
             profile_data_store_ptr[count]->birthday.m,
             profile_data_store_ptr[count]->birthday.d);
            printf("Addr. : %s\n", profile_data_store_ptr[count]->address);
            printf("Comm. : %s\n\n", profile_data_store_ptr[count]->note);
            count++;
        }
    }
    else if (num > 0)
    {
        if (num > profile_data_nitems)
            num = profile_data_nitems;
        count = 0;
        while (count < num)
        {
            printf("Id    : %d\n", profile_data_store_ptr[count]->id);
            printf("Name  : %s\n", profile_data_store_ptr[count]->name);
            printf("Birth : %04d-%02d-%02d\n", profile_data_store_ptr[count]->birthday.y,
             profile_data_store_ptr[count]->birthday.m,
             profile_data_store_ptr[count]->birthday.d);
            printf("Addr. : %s\n", profile_data_store_ptr[count]->address);
            printf("Comm. : %s\n\n", profile_data_store_ptr[count]->note);
            count++;
        }
    }
    else if (num < 0)
    {
        if (num < -profile_data_nitems)
            num = -profile_data_nitems;
        count = profile_data_nitems + num;
        while (count < profile_data_nitems)
        {
            printf("Id    : %d\n", profile_data_store_ptr[count]->id);
            printf("Name  : %s\n", profile_data_store_ptr[count]->name);
            printf("Birth : %04d-%02d-%02d\n", profile_data_store_ptr[count]->birthday.y,
             profile_data_store_ptr[count]->birthday.m,
             profile_data_store_ptr[count]->birthday.d);
            printf("Addr. : %s\n", profile_data_store_ptr[count]->address);
            printf("Comm. : %s\n\n", profile_data_store_ptr[count]->note);
            count++;
        }
    }
}

/*
Overview: Read data and register in array.
@argument: {char} cmd - Command alphabet.
@argument: {char *} param - Command argument.
@return: No return
*/
void cmd_read(char cmd, char *param)
{
    char line[MAX_LINE_LEN + 1];
    fp = fopen(param, "r");
    if (fp != NULL)
    {
        while (get_line(line))
        {
            parse_line(line);
        }
    }
    else
    {
        fprintf(stderr, "Enterd file cannot be opened.\n");
    }
    fclose(fp);
}

/*
Overview: Export registered data.
@argument: {char} cmd - Command alphabet.
@argument: {char *} param - Command argument.
@return: No return
*/
void cmd_write(char cmd, char *param)
{
    int i;
    fp = fopen(param, "w");
    if (fp != NULL)
    {
        for (i = 0; i < profile_data_nitems; i++)
        {
            fprintf(fp, "%d,%s,%04d-%02d-%02d,%s,%s\n", profile_data_store_ptr[i]->id,
             profile_data_store_ptr[i]->name, profile_data_store_ptr[i]->birthday.y,
             profile_data_store_ptr[i]->birthday.m, profile_data_store_ptr[i]->birthday.d,
             profile_data_store_ptr[i]->address, profile_data_store_ptr[i]->note);
        }
    }
    else
    {
        fprintf(stderr, "Enterd file cannot be opened.\n");
    }
    fclose(fp);
}

/*
Overview: Search for matching data from registered data and output.
@argument: {char} cmd - Command alphabet.
@argument: {char *} param - Command argument.
@return: No return
*/
void cmd_find(char cmd, char *param)
{
    int i;
    char id_tmp[9];
    char birthday_tmp[11];
    struct profile *p;
    for (i = 0; i < profile_data_nitems; i++)
    {
        p = profile_data_store_ptr[i];
        sprintf(id_tmp, "%d", p->id);
        sprintf(birthday_tmp,"%04d-%02d-%02d", p->birthday.y, p->birthday.m, p->birthday.d);
        if (
            strcmp(id_tmp, param) == 0 ||
            strcmp(p->name, param) == 0 ||
            strcmp(birthday_tmp, param) == 0 ||
            strcmp(p->address, param) == 0 ||
            strcmp(p->note, param) == 0)
        {
            printf("Id    : %d\n", profile_data_store_ptr[i]->id);
            printf("Name  : %s\n", profile_data_store_ptr[i]->name);
            printf("Birth : %04d-%02d-%02d\n", profile_data_store_ptr[i]->birthday.y,
             profile_data_store_ptr[i]->birthday.m, profile_data_store_ptr[i]->birthday.d);
            printf("Addr. : %s\n", profile_data_store_ptr[i]->address);
            printf("Comm. : %s\n\n", profile_data_store_ptr[i]->note);
        }
    }
}

/*
Overview: Specify the column with an argument and sort the registered data.
@argument: {char} cmd - Command alphabet.
@argument: {char *} param - Command argument.
@return: No return
*/
void cmd_sort(char cmd, char *param)
{
    switch (atoi(param))
    {
    case 1:
        quicksort_id(0, profile_data_nitems - 1);
        break;
    case 2:
        quicksort_name(0, profile_data_nitems - 1);
        break;
    case 3:
        quicksort_birthday(0, profile_data_nitems - 1);
        break;
    case 4:
        quicksort_address(0, profile_data_nitems - 1);
        break;
    case 5:
        quicksort_note(0, profile_data_nitems - 1);
        break;
    default:
        break;
    }
}

/*
Overview: Output partial match data in array.
@argument: {char} cmd - Command alphabet.
@argument: {char *} param - Command argument.
@return: No return
*/
void cmd_match(char cmd, char *param)
{
    int i;
    for (i = 0; i < profile_data_nitems; i++)
    {
        char string[2][1024];
        char find[1024];

        sprintf(string[0], "%d, %s, %d-%d-%d, %s, %s\n", profile_data_store_ptr[i]->id,
         profile_data_store_ptr[i]->name, profile_data_store_ptr[i]->birthday.y,
         profile_data_store_ptr[i]->birthday.m, profile_data_store_ptr[i]->birthday.d,
         profile_data_store_ptr[i]->address, profile_data_store_ptr[i]->note);
        sprintf(string[1], "%d, %s, %d-%02d-%02d, %s, %s\n", profile_data_store_ptr[i]->id,
         profile_data_store_ptr[i]->name, profile_data_store_ptr[i]->birthday.y,
         profile_data_store_ptr[i]->birthday.m, profile_data_store_ptr[i]->birthday.d,
         profile_data_store_ptr[i]->address, profile_data_store_ptr[i]->note);

        strcpy(find, param);

        upper(string[0]);
        upper(string[1]);
        upper(find);

        if (match(string[0], find) || match(string[1], find))
        {
            printf("Id    : %d\n", profile_data_store_ptr[i]->id);
            printf("Name  : %s\n", profile_data_store_ptr[i]->name);
            printf("Birth : %04d-%02d-%02d\n", profile_data_store_ptr[i]->birthday.y,
             profile_data_store_ptr[i]->birthday.m, profile_data_store_ptr[i]->birthday.d);
            printf("Addr. : %s\n", profile_data_store_ptr[i]->address);
            printf("Comm. : %s\n\n", profile_data_store_ptr[i]->note);
        }
    }
}

/*
Overview: Calls functions when the command is input.
@argument: {char} cmd - Command alphabet.
@argument: {char *} param - Command argument.
@return: No return
*/
void exec_command(char cmd, char *param)
{
    switch (cmd)
    {
    case 'Q':
        cmd_quit();
        break;
    case 'C':
        cmd_check(cmd);
        break;
    case 'P':
        cmd_print(cmd, param);
        break;
    case 'R':
        cmd_read(cmd, param);
        break;
    case 'W':
        cmd_write(cmd, param);
        break;
    case 'F':
        cmd_find(cmd, param);
        break;
    case 'S':
        cmd_sort(cmd, param);
        break;
    case 'M':
        cmd_match(cmd, param);
        break;
    default:
        fprintf(stderr, "Unregistered Command Is Entered.\n");
        break;
    }
}

/*
Overview: Replaces c1 in the string with c2.
@argument: {char *} str - String.
@argument: {char} c1 - Replaced.
@argument: {char} c2 - Replace.
@return: {int} diff - Number of replacements.
*/
int subst(char *str, char c1, char c2)
{
    int diff = 0;
    char *p;

    p = str;
    while (*p != '\0')
    {
        if (*p == c1)
        {
            *p = c2;
            diff++;
        }
        p++;
    }
    return diff;
}

/*
Overview: Separate string by the specified number of characters/times.
@argument: {char *} str - String.
@argument: {char *} ret[] - Separated string.
@argument: {char} sep - Delimiter.
@argument: {int} max - Maximum number to divide.
@return: Number of divisions
*/
int split(char *str, char *ret[], char sep, int max)
{
    int count = 1;
    ret[0] = str;

    while (*str)
    {
        if (count >= max)
            break;
        if (*str == sep)
        {
            *str = '\0';
            ret[count++] = str + 1;
        }
        str++;
    }

    return count;
}

/*
Overview: Get line from file or standard input.
@argument: {char *} line - Full text.
@return: Whether there is next line.
*/
int get_line(char *line)
{
    if (fp != NULL && fgets(line, MAX_LINE_LEN + 1, fp) != NULL)
    {
        subst(line, '\n', '\0');
        return 1;
    }
    if (fgets(line, MAX_LINE_LEN + 1, stdin) == NULL)
    {
        return 0;
    }
    else
    {
        subst(line, '\n', '\0');
        return 1;
    }
}

/*
Overview: New data registration.
@argument: {struct profile *} profile_data_store - Pointer to store the new data.
@argument: {char *} line - One line to register.
@return: Successful or not.
*/
int new_profile(struct profile *profile_data_store, char *line)
{
    int max_line = 5, max_date = 3;
    char *ret[80] = {0}, *date[80] = {0}, sep_line = ',', sep_date = '-';

    if (split(line, ret, sep_line, max_line) != 5)
    {
        return -1;
    }

    split(line, ret, sep_line, max_line);
    split(ret[2], date, sep_date, max_date);

    profile_data_store->id = atoi(ret[0]);

    strcpy(profile_data_store->name, ret[1]);

    profile_data_store->birthday.y = atoi(date[0]);
    profile_data_store->birthday.m = atoi(date[1]);
    profile_data_store->birthday.d = atoi(date[2]);

    strcpy(profile_data_store->address, ret[3]);

    profile_data_store->note = (char *)malloc(sizeof(char) * (strlen(ret[4]) + 1));
    strcpy(profile_data_store->note, ret[4]);
    return 0;
}

/*
Overview: Check new data registration or command.
@argument: {char *} line - One line.
@return: No return
*/
void parse_line(char *line)
{
    if (*line == '%')
    {
        exec_command(line[1], &line[3]);
    }
    else
    {
        new_profile(profile_data_store_ptr[profile_data_nitems++], line);
    }
}

/*
Overview: Main function.
@return: Successful or not.
*/
int main(void)
{
    clock_t start, end;
    char line[MAX_LINE_LEN + 1];

    if (time_record)
        start = clock();

    make_profile_shadow(profile_data_store, profile_data_store_ptr, 10000);
    while (get_line(line))
    {
        parse_line(line);
    }

    if (show_size)
    {
        printf("sizeof(struct profile) = %ld\n", sizeof(struct profile));
        printf("sizeof(struct profile) = %ld\n", sizeof(struct profile *));
        printf("sizeof(struct profile) = %ld\n", sizeof(profile_data_store));
        printf("sizeof(struct profile) = %ld\n", sizeof(profile_data_store_ptr));
    }

    if (time_record)
    {
        end = clock();
        printf("%.5f seconds to finish\n", (double)(end - start) / CLOCKS_PER_SEC);
    }

    return 0;
}

\end{Verbatim}


%--------------------------------------------------------------------%
\subsection{ポインタや構造体のサイズ} \label{sec:8.2}
%--------------------------------------------------------------------%

データの備考欄を\verb|malloc|関数を使わずにサイズ指定を行う場合．

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
// Structure that does not use malloc function.
struct profile
{
    int id;
    char name[70];
    struct date birthday;
    char address[70];
    char note[1024];
};

\end{Verbatim}

\verb|profile_data_store|をポインタに変更．

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
void make_profile_shadow(struct profile data_store[], struct profile *shadow[], int size)
{
    int i;
    for (i = 0; i < size; i++)
        shadow[i] = &data_store[i];
}

\end{Verbatim}

%--------------------------------------------------------------------%
\subsection{パフォーマンスチューニング} \label{sec:8.3}
%--------------------------------------------------------------------%

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
void swap_p(struct profile **source, struct profile **destination)
{
    struct profile *tmp;

    tmp = *source;
    *source = *destination;
    *destination = tmp;
}

\end{Verbatim}

%--------------------------------------------------------------------%
\subsection{split関数の別実装} \label{sec:8.4}
%--------------------------------------------------------------------%

\begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
int split(char *str, char *ret[], char sep, int max)
{
    int i, count = 0;
    subst(str, sep, '\0'); // カンマをNULL終端に置き換え
    for (i = 0; i < max; i++)
    {
        ret[i] = str;
        str += strlen(str) + 1;
        count++;
    }
    return count;
}
\end{Verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 参考文献
%   実際に，参考にした書籍等の奥付などを見て書くこと．
%   本文で引用する際は，\cite{book:algodata}のように書けばよい．
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{99}
  \bibitem{book:algodata} 平田富雄，アルゴリズムとデータ構造，森北出版，1990.
  \bibitem{web:atoi} C言語のatoiで出来ること, https://arma-search.jp/article/clanguage-atoi, 2020/05/20.
  \bibitem{web:mysql} C言語からMySQL, https://tech.pjin.jp/blog/2017/08/20/mysql\_c\_windows5/, 2020/07/28.
\end{thebibliography}

%--------------------------------------------------------------------%
\end{document}
